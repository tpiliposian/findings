# Decimal precision oversight in cross-layer token transactions

## Description

Path: `fuel-bridge/packages/solidity-contracts/contracts/messaging/gateway/FuelERC20Gateway/FuelERC20GatewayV4.sol, fuel-bridge/packages/fungible-token/bridge-fungible-token/src/main.sw`

The sway bridge contract uses the same number of decimals for all bridged tokens, which is determined by the `DECIMALS` configurable constant or default value of 9 decimals.
```rust
const DEFAULT_DECIMALS: u8 = 9u8;

configurable {
    DECIMALS: u64 = 9u64,
    BRIDGED_TOKEN_GATEWAY: b256 = 0x00000000000000000000000096c53cd98B7297564716a8f2E1de2C83928Af2fe,
}
```
```rust

impl SRC20 for Contract {
    ...

    #[storage(read)]
    fn decimals(asset: AssetId) -> Option<u8> {
        match storage.tokens_minted.get(asset).try_read() {
            Some(_) => Some(DECIMALS.try_as_u8().unwrap_or(DEFAULT_DECIMALS)),
            None => None,
        }
    }
}
```
In contrast, the Fuel gateway on Ethereum (`FuelERC20GatewayV4.sol`) allows bridging any tokens by default, as the `whitelistRequired` state variable is set to `false`. Tokens bridged through this gateway may have different decimal amounts. For example, `WETH` has 18 decimals, whereas `USDC` has 6 decimals.

When a token is bridged from Ethereum to Fuel, a new `sub_id` is generated by the sway bridge contract based on the token's address on Ethereum, and the corresponding bridged amount is minted.
```rust
let sub_id = _generate_sub_id_from_metadata(message_data.token_address, message_data.token_id);
```
```rust
mint(sub_id, amount);
```

However, both bridged `WETH` and `USDC` tokens will have the same decimal amount specified by `DECIMALS`.

On the Fuel Gateway's (`FuelERC20GatewayV4.sol`) side, during the bridging process, token decimals are adjusted to match the specified `FUEL_ASSET_DECIMALS = 9`. This means that for the `WETH` token, the amount is divided by `10^9`, while for the `USDC` token, the amount remains unchanged.
```rust
function _adjustDepositDecimals(uint8 tokenDecimals, uint256 amount) internal pure virtual returns (uint256) {
    if (tokenDecimals > FUEL_ASSET_DECIMALS) {
        unchecked {
            uint256 precision = 10 ** (tokenDecimals - FUEL_ASSET_DECIMALS);
            if (amount % precision != 0) {
                revert InvalidAmount();
            }
            return _divByNonZero(amount, precision);
        }
    }
    return amount;
}
```

The bridged amount of USDC is not adjusted to 9 decimals by the sway bridge contract. This means that a user would receive a 1000x smaller amount of bridged USDC.

## Code Snippet

```rust
    function _deposit(
        address tokenAddress,
        uint256 amount,
        uint256 l2MintedAmount,
        bytes memory messageData
    ) internal virtual {
        ////////////
        // Checks //
        ////////////
        if (l2MintedAmount == 0) revert CannotDepositZero();
        if (l2MintedAmount > uint256(type(uint64).max)) revert InvalidAmount();

        /////////////
        // Effects //
        /////////////
        uint256 updatedDeposits = _deposits[tokenAddress] + l2MintedAmount;
        if (updatedDeposits > type(uint64).max) revert BridgeFull();

        if (whitelistRequired && updatedDeposits > _depositLimits[tokenAddress]) {
            revert GlobalDepositLimit();
        }

        _deposits[tokenAddress] = updatedDeposits;

        /////////////
        // Actions //
        /////////////
        //send message to gateway on Fuel to finalize the deposit
        sendMessage(CommonPredicates.CONTRACT_MESSAGE_PREDICATE, messageData);

        //transfer tokens to this contract and update deposit balance
        IERC20MetadataUpgradeable(tokenAddress).safeTransferFrom(msg.sender, address(this), amount);

        //emit event for successful token deposit
        emit Deposit(bytes32(uint256(uint160(msg.sender))), tokenAddress, amount);
    }
```
```rust
impl SRC20 for Contract {
    #[storage(read)]
    fn total_assets() -> u64 {
        storage.total_assets.try_read().unwrap_or(0)
    }

    #[storage(read)]
    fn total_supply(asset: AssetId) -> Option<u64> {
        storage.tokens_minted.get(asset).try_read()
    }

    #[storage(read)]
    fn name(asset: AssetId) -> Option<String> {
        let l1_address = _asset_to_l1_address(asset);
        storage.l1_names.get(l1_address).read_slice()
    }

    #[storage(read)]
    fn symbol(asset: AssetId) -> Option<String> {
        let l1_address = _asset_to_l1_address(asset);
        storage.l1_symbols.get(l1_address).read_slice()
    }

    #[storage(read)]
    fn decimals(asset: AssetId) -> Option<u8> {
        match storage.tokens_minted.get(asset).try_read() {
            Some(_) => Some(DECIMALS.try_as_u8().unwrap_or(DEFAULT_DECIMALS)),
            None => None,
        }
    }
}
```

## Remediation

Modify the `sendMetadata()` function in the `FuelERC20GatewayV4` gateway to include the token's decimals when passing metadata to the sway bridge on the Fuel chain.  The sway bridge should adjust minted amount based on tokenâ€™s decimals from metadata.
